# Визначення моменту закінчення `time_t` та дослідження сегментів виконуваного файлу

## Опис завдання
Мета — визначити момент часу, коли тип `time_t` досягне свого максимального значення, і дослідити, як це залежить від 32- та 64-бітної архітектури. Також дослідити структуру сегментів виконуваного файлу.

## Код програми

```c
#include <stdio.h>
#include <time.h>
#include <limits.h>

int main(){
    printf("Max int: %d\n", INT_MAX);
    printf("Max long: %ld\n", LONG_MAX);
    
    time_t max_32 = (time_t)INT_MAX;
    time_t max_64 = (time_t)LONG_MAX;
    time_t s_max_64 = (time_t)(LONG_MAX / 1000);

    printf("32-bit time_t limit: %s\n", ctime(&max_32));
    printf("64-bit time_t limit: %s\n", ctime(&max_64));
    printf("Scaled 64-bit time_t limit: %s\n", ctime(&s_max_64));

    return 0;
}
```

## Як запустити програму
1. Створіть файл, наприклад `time_limit.c`.
2. Скомпілюйте:
   ```bash
   gcc -Wall time_limit.c -o time_limit
   ```
3. Запустіть:
   ```bash
   ./time_limit
   ```

## Результати дослідження

- На **32-бітній архітектурі** (`time_t` має 4 байти):
  - Максимальне значення часу досягається приблизно 19 січня 2038 року (`2038-01-19 03:14:07 UTC`).
  - Це явище називається **Проблема 2038 року**.

- На **64-бітній архітектурі** (`time_t` має 8 байтів):
  - Межа часу настільки велика, що для практичного використання недосяжна (понад 292 мільярди років).

## Дослідження сегментів виконуваного файлу

1. Після компіляції переглянемо розміри сегментів:

   ```bash
   size time_limit
   ```

   Приклад виводу:

   ```
   text    data     bss     dec     hex filename
   1234     567      89     1890    762  time_limit
   ```

   - `text` — код програми (функції).
   - `data` — ініціалізовані глобальні/статичні змінні.
   - `bss` — неініціалізовані глобальні/статичні змінні (автоматично заповнюються нулями).

2. Також можна дослідити таблицю символів:

   ```bash
   nm time_limit
   ```

3. Для повнішого аналізу сегментів:

   ```bash
   objdump -h time_limit
   ```

## Висновки

- Тип `time_t` на 32-бітах обмежений і викликає переповнення у 2038 році.
- На 64-бітах ця проблема практично зникає.
- Виконуваний файл розділений на сегменти (text, data, bss), кожен з яких виконує свою роль у пам'яті.
