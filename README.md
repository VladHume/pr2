# Завдання 1: визначення моменту закінчення `time_t` та дослідження сегментів виконуваного файлу

## Опис завдання
Визначити момент часу, коли тип `time_t` досягне свого максимального значення, і дослідити, як це залежить від 32- та 64-бітної архітектури. Також дослідити структуру сегментів виконуваного файлу.

## Код програми

```c
#include <stdio.h>
#include <time.h>
#include <limits.h>

int main(){
	printf("Max int 32 bit: %d\n", INT_MAX);
	printf("Max int 64 bit: %ld\n", LONG_MAX);
	
	time_t max_32 = (time_t)INT_MAX;
	time_t max_64 = (time_t)LONG_MAX;
	time_t s_max_64 = (time_t)(LONG_MAX /1000);

	printf("32 bit: %s\n", ctime(&max_32));
	printf("64 bit: %s\n", ctime(&max_64));
	printf("64 bit(but long/1000): %s\n", ctime(&s_max_64));

	return 0;
}
```

## Як запустити програму
1. Створіть файл, наприклад `task1.c`.
2. Скомпілюйте:
   ```bash
   gcc -Wall task1.c -o task1
   ```
3. Запустіть:
   ```bash
   ./task1
   ```

## Результати дослідження

- На **32-бітній архітектурі** (`time_t` має 4 байти):
  - Максимальне значення часу досягається 19 січня 2038 року (`2038-01-19 03:14:07 UTC`).
  - Це явище називається **Проблема 2038 року**.

- На **64-бітній архітектурі** (`time_t` має 8 байтів):
  - Межа часу настільки велика, що для практичного використання недосяжна (понад 292 мільярди років).            Бібліотека ctime не може обробити значення long, як результат виводить null, значення дани виводиться 
    якщо long/1000
    
![Скриншот виконання](task1_1.png)
## Дослідження сегментів виконуваного файлу

1. Після компіляції переглянемо розміри сегментів:

   ```bash
   size task1
   ```

   Вивід:

   ![Вивід](size.png)
   

   - `text` — код програми (функції).
   - `data` — ініціалізовані глобальні/статичні змінні.
   - `bss` — неініціалізовані глобальні/статичні змінні (автоматично заповнюються нулями).
## Висновки

- Тип `time_t` на 32-бітах обмежений і викликає переповнення у 2038 році.
- На 64-бітах ця проблема практично зникає.
- Виконуваний файл розділений на сегменти (text, data, bss), кожен з яких виконує свою роль у пам'яті.


# Завдання 2:
### Код
```c
#include <stdio.h>

int main(){
	printf("Hello world");
	return 0;
}
```
### Результати виконання дослідження
#### Команда
```bash
ls -l task2
```
#### Скриншот виконання
![image](https://github.com/user-attachments/assets/d0a48be2-89f1-4559-960a-0532ba90031b)
#### Команда
```bash
size task2
```
#### Скриншот виконання
![image](https://github.com/user-attachments/assets/ad33281c-b85d-4963-a46f-bc232544c62b)

### Після додавання глобального масиву 
```c
int arr[1000];
```
#### Команди 
```bash
ls -l task2
size task2
```
#### Скриншот виконання
![image](https://github.com/user-attachments/assets/2923475e-628f-4626-bd21-e5cdae123ce7)

### Після оголошення початкового елемента масива
```c
arr[0] = 10;
```
#### Команди 
```bash
ls -l task2
size task2
```

#### Скриншот виконання
![image](https://github.com/user-attachments/assets/222b8f5b-2b25-42c4-91ab-3b378091731d)

### Після оголошення та ініціалізації великого масиву всередині функції
```c
int arr2[1000] = {10};
```
#### Команди 
```bash
ls -l task2
size task2
```

#### Скриншот виконання
![image](https://github.com/user-attachments/assets/d44f80d9-0f51-4774-bc28-08a9bc7e2545)

### Виконання прапорців налагодження та оптимізації
```bash
gcc -Wall -g -O2 -o task2 task2.c
```
#### Скриншот виконання

![image](https://github.com/user-attachments/assets/807f0ebd-1b3b-4423-ae13-d0d954e99610)

### З отриманих результатів можна зробити такі висновки:

1. Сегменти виконуваного файлу мають різне призначення:

- .text містить програмний код,

- .data — ініціалізовані глобальні змінні,

- .bss — неініціалізовані глобальні змінні.

2. Неініціалізовані глобальні змінні (у .bss) не збільшують розмір виконуваного файлу, оскільки вони не зберігаються в ньому. Лише вказується обсяг памʼяті, який ОС має виділити під час виконання програми.

3. Ініціалізовані глобальні змінні (у .data) зберігаються у виконуваному файлі, тому додають до його розміру.

4. Локальні змінні, навіть великі масиви, не впливають на розмір виконуваного файлу, оскільки зберігаються у стеку під час виконання. Їх не видно в сегментах файлу.

5. Додавання налагоджувальної інформації (компіляція з -g) значно збільшує розмір файлу, але не змінює розміри сегментів .text, .data, .bss.

6. Оптимізація (наприклад, з -O2) може зменшити розмір сегмента .text, завдяки видаленню зайвого коду або спрощенню інструкцій, що робить виконуваний файл легшим та ефективнішим.

# Завдання 3

## Опис завдання: 
Скомпілюйте й запустіть тестову програму, щоб визначити приблизне
розташування стека у вашій системі:
```c
#include <stdio.h>

int main() {
	int i;
	printf("The stack top is near %p\n", &i);
	return 0;
}
```
Знайдіть розташування сегментів даних і тексту, а також купи всередині
сегмента даних, оголосіть змінні, які будуть поміщені в ці сегменти, і
виведіть їхні адреси.
Збільшіть розмір стека, викликавши функцію й оголосивши кілька
великих локальних масивів. Яка зараз адреса вершини стека?

## Дослідження
Отримуємо приблизне розташування стека у системі
![image](https://github.com/user-attachments/assets/fc7a5bb2-783b-4e47-8aca-738656854751)

Напишемо код, для знаходження розташувань інших сегментів
### Код
[task3_m.c](https://github.com/VladHume/pr2/blob/master/task3_m.c)
### Скриншот з результатами
![image](https://github.com/user-attachments/assets/047df42e-efa6-4ab8-ad46-5ebe17352dd0)
## Висновки по виконанню завдання
1. Змінні розміщуються в різних сегментах пам’яті, залежно від їх типу:

	- Локальні — в стеці.

	- Динамічні — у купі.

	- Глобальні та статичні — у сегменті даних.

	- Константи — у сегменті rodata (часто розташованому в секції text).

2. Адреси цих змінних будуть різними:

	- Зазвичай стек має найвищі адреси, а текст/rodata — найнижчі.

	- Це допомагає системі розмежовувати типи пам’яті і керувати доступом.

3. Безпека та оптимізація:

	- Дані в rodata не змінюються — що дозволяє ОС захищати ці області (read-only).

	- Стек швидкий, але обмежений у розмірі.

	- Купа — для більших обсягів даних, але потребує явного керування (malloc/free).

# Завдання 4
gstask встановити не вдалось, тому дослідження проводив через gdb вручну
Для дослідження використовував код програми наданий у прикладі
## При запуску програми із завдання маємо такий вивід
![image](https://github.com/user-attachments/assets/ad45a71b-f048-4b23-a477-a5de376d2047)

Для переходу у інший термінал, щоб переглянути запущений процес використовуємо комбінацію клавіш
```ngnix
Ctrl + Alt + F2
```
У новому терміналі отримуємо PID процесу 
![image](https://github.com/user-attachments/assets/0d0bf7f8-3bb9-4304-9fa9-45d932d201bb)
Маємо такий вивід
![image](https://github.com/user-attachments/assets/e813774b-ffed-4532-b7d9-019ece05d944)

# Завдання 5
Ні, обійтися без лічильника команд (IP) не можна.

Причини:

- IP визначає, яку інструкцію виконувати далі.

- Стек зберігає лише адресу повернення, а не поточну позицію виконання.

- Без IP процесор не знає, що декодувати і виконувати.

## Висновок: 
стек допомагає при переходах, але не замінює лічильник команд.

# Завдання 6
## Код
[threads.c](https://github.com/VladHume/pr2/blob/master/threads.c)

## Щоб скомпілюватии
```bash
gcc -Wall -o threads threads.c -pthread
```
## Результат виконання
![image](https://github.com/user-attachments/assets/c187de4e-adac-4881-b667-f496e241242c)

## Методи створення багатопотокових програм, які використовуються в коді:
- Створення потоків за допомогою pthread_create: Це функція для створення нових потоків, кожен з яких виконує функцію worker.

- Синхронізація за допомогою м'ютекса: Для захисту змінної global_counter від одночасного доступу кількох потоків використовується м'ютекс. Це забезпечує безпечний доступ до спільної пам'яті.

- Очікування завершення потоків за допомогою pthread_join: Основний потік чекає завершення всіх дочірніх потоків, щоб програма не завершилася до того, як потоки виконають свою роботу.

- Знищення м'ютекса: Після завершення роботи програми м'ютекс знищується для звільнення ресурсів.

## Висновок:
Програма використовує багатопотоковість з синхронізацією доступу до спільних ресурсів за допомогою м'ютекса, що дозволяє безпечно змінювати значення глобальної змінної.












